schema {
  query: Queries
  mutation: Mutations
}

type AdminBookingType {
  id: ID!
  checkIn: Date!
  checkOut: Date!
  cabins: [CabinType!]!
  firstName: String!
  lastName: String!
  phone: String!
  receiverEmail: String!
  timestamp: DateTime!
  internalParticipants: Int!
  externalParticipants: Int!
  isTentative: Boolean!
  isDeclined: Boolean!
  price: Int
  numberOfNights: Int
  isInternalPrice: Int
}

type AdminEventSignOff {
  event: EventType
}

type AllBookingsType {
  id: ID!
  checkIn: Date!
  checkOut: Date!
  cabins: [CabinType!]!
}

input AnswerInput {
  questionId: ID!
  answer: String!
}

type AnswerType {
  uuid: UUID!
  question: QuestionType!
  answer: String!
  id: UUID
}

type ArchiveDocumentType {
  id: ID!
  title: String!
  typeDoc: ArchiveDocumentTypeDoc!
  fileLocation: String!
  featured: Boolean!
  year: Int
  webLink: String
  thumbnail: String
}

enum ArchiveDocumentTypeDoc {
  BUDSJETT_OG_REGNSKAP
  GENERALFORSAMLING
  ARBOKER
  FORENINGENS_LOVER
  STOTTE_FRA_HS
  UTVEKSLING
  ANNET
}

type AssignMembership {
  membership: MembershipType
  ok: Boolean
}

type AttemptCapturePayment {
  status: String
  order: OrderType
}

type AuthUser {
  token: String
  user: UserType
  isIndokStudent: Boolean
  idToken: String
}

input BaseFormInput {
  name: String
  organizationId: ID
  description: String
}

input BaseListingInput {
  title: String
  description: String
  startDatetime: DateTime
  endDatetime: DateTime
  deadline: DateTime
  applicationUrl: String
  formId: ID
  application: Boolean
  interview: Boolean
  case: Boolean
  readMoreUrl: String
}

input BaseQuestionInput {
  questionType: QuestionTypeEnum
  question: String
  description: String
  mandatory: Boolean
}

type BlogPostType {
  id: ID!
  title: String!
  text: String!
  publishDate: DateTime!
  author: UserType
  blog: BlogType
}

type BlogType {
  id: ID!
  organization: OrganizationType
  name: String!
  description: String!
  blogPosts: [BlogPostType!]!
}

input BookingInput {
  firstName: String
  lastName: String
  phone: String
  receiverEmail: String
  checkIn: Date
  checkOut: Date
  internalParticipants: Int
  externalParticipants: Int
  cabins: [Int]
}

type BookingResponsibleType {
  id: ID!
  firstName: String
  lastName: String
  phone: Int
  email: String
  active: Boolean
}

type CabinType {
  id: ID!
  name: String!
  maxGuests: Int!
  internalPrice: Int!
  externalPrice: Int!
}

input CategoryInput {
  name: String
}

type CategoryType {
  id: ID!
  name: String!
}

type CreateArchiveDocument {
  ok: Boolean
  arhiveDocument: ArchiveDocumentType
}

type CreateBlog {
  ok: Boolean
  blog: BlogType
}

type CreateBlogPost {
  ok: Boolean
  blogPost: BlogPostType
}

type CreateBooking {
  ok: Boolean
  booking: AllBookingsType
}

type CreateCategory {
  ok: Boolean
  category: CategoryType
}

type CreateEvent {
  ok: Boolean
  event: EventType
}

input CreateEventInput {
  title: String!
  description: String!
  startTime: DateTime!
  isAttendable: Boolean!
  endTime: DateTime
  location: String
  categoryId: ID
  image: String
  deadline: DateTime
  signupOpenDate: DateTime
  availableSlots: Int
  price: Float
  shortDescription: String
  hasExtraInformation: Boolean
  contactEmail: String
  bindingSignup: Boolean
  allowedGradeYears: [Int]
  organizationId: ID!
}

type CreateForm {
  form: FormType
  ok: Boolean
}

input CreateFormInput {
  name: String!
  organizationId: ID!
  description: String
}

type CreateListing {
  ok: Boolean
  listing: ListingType
}

input CreateListingInput {
  title: String!
  description: String
  startDatetime: DateTime
  endDatetime: DateTime
  deadline: DateTime!
  applicationUrl: String
  formId: ID
  application: Boolean
  interview: Boolean
  case: Boolean
  readMoreUrl: String
  organizationId: ID!
}

type CreateOrganization {
  organization: OrganizationType
  ok: Boolean
}

type CreateProduct {
  ok: Boolean
  product: ProductType
}

input CreateProductInput {
  name: String!
  description: String!
  price: Decimal!
  organizationId: ID!
  totalQuantity: Int!
  maxBuyableQuantity: Int!
}

type CreateQuestion {
  ok: Boolean
  question: QuestionType
}

input CreateQuestionInput {
  questionType: QuestionTypeEnum
  question: String!
  description: String
  mandatory: Boolean
}

type CreateUpdateAndDeleteOptions {
  ok: Boolean
  options: [OptionType]
}

scalar Date

scalar DateTime

scalar Decimal

type DeleteAnswer {
  ok: Boolean
  deletedUuid: ID
}

type DeleteAnswersToForm {
  ok: Boolean
}

type DeleteArchiveDocument {
  ok: Boolean
  archiveDocument: ArchiveDocumentType
}

type DeleteBlog {
  ok: ID
}

type DeleteBlogPost {
  ok: Boolean
}

type DeleteBooking {
  ok: Boolean
  bookingId: ID
}

type DeleteCategory {
  ok: Boolean
  category: CategoryType
}

type DeleteEvent {
  ok: Boolean
  event: EventType
}

type DeleteForm {
  deletedId: ID
  ok: Boolean
}

type DeleteJSONWebTokenCookie {
  deleted: Boolean!
}

type DeleteListing {
  ok: Boolean
  listingId: ID
}

type DeleteOrganization {
  organization: OrganizationType
  ok: Boolean
}

type DeleteQuestion {
  ok: Boolean
  deletedId: ID
}

input EmailInput {
  firstName: String
  lastName: String
  phone: String
  receiverEmail: String
  checkIn: Date
  checkOut: Date
  internalParticipants: Int
  externalParticipants: Int
  cabins: [Int]
  emailType: String
  extraInfo: String = ""
}

type EventSignOff {
  isFull: Boolean
  event: EventType
}

type EventSignUp {
  isFull: Boolean
  event: EventType
}

input EventSignUpInput {
  extraInformation: String
}

type EventType {
  id: ID!
  title: String!
  description: String!
  startTime: DateTime!
  isAttendable: Boolean!
  organization: OrganizationType!
  publisher: UserType
  endTime: DateTime
  location: String
  category: CategoryType
  image: String
  shortDescription: String
  hasExtraInformation: Boolean!
  contactEmail: String!
  signupOpenDate: DateTime
  deadline: DateTime
  price: Float
  bindingSignup: Boolean!
  userAttendance: UserAttendingType
  isFull: Boolean
  usersOnWaitingList: [SignUpType]
  usersAttending: [SignUpType]
  allowedGradeYears: [Int]
  availableSlots: Int
  product: ProductType
}

type FormType {
  id: ID!
  organization: OrganizationType
  name: String!
  description: String!
  questions: [QuestionType!]!
  responders(userId: ID): [UserType]
  responder(userId: ID!): UserType
  responses: [ResponseType]
  response(responsePk: UUID): ResponseType
}

scalar GenericScalar

type GetIDToken {
  idToken: String!
}

type InitiateOrder {
  redirect: String
  orderId: UUID
}

type ListingType {
  id: ID!
  title: String!
  description: String!
  viewCount: Int!
  startDatetime: DateTime!
  endDatetime: DateTime!
  deadline: DateTime!
  applicationUrl: String
  readMoreUrl: String
  heroImageUrl: String
  form: FormType
  slug: String!
  organization: OrganizationType!
  chips: [String]!
}

input MembershipInput {
  userId: ID
  organizationId: ID
  groupId: ID
}

type MembershipType {
  id: ID!
  user: UserType!
  organization: OrganizationType!
  group: ResponsibleGroupType
}

type Mutations {
  createBlog(description: String, name: String, organizationId: ID): CreateBlog
  deleteBlog(blogId: ID): DeleteBlog
  updateBlog(blogData: UpdateBlogInput): UpdateBlog
  createBlogPost(authorId: ID, blogId: ID, text: String, title: String): CreateBlogPost
  deleteBlogPost(blogPostId: ID): DeleteBlogPost
  updateBlogPost(blogPostData: UpdateBlogPostInput): UpdateBlogPost
  initiateOrder(fallbackRedirect: String, productId: ID!, quantity: Int): InitiateOrder
  attemptCapturePayment(orderId: ID!): AttemptCapturePayment
  createProduct(productData: CreateProductInput!): CreateProduct
  createQuestion(formId: ID, questionData: CreateQuestionInput!): CreateQuestion
  updateQuestion(id: ID!, questionData: BaseQuestionInput!): UpdateQuestion
  deleteQuestion(id: ID!): DeleteQuestion
  createForm(formData: CreateFormInput!, listingId: ID): CreateForm
  updateForm(formData: BaseFormInput!, id: ID): UpdateForm
  deleteForm(id: ID!): DeleteForm
  deleteAnswer(uuid: ID!): DeleteAnswer
  submitAnswers(answersData: [AnswerInput], formId: ID!): SubmitOrUpdateAnswers
  deleteAnswers(formId: ID): DeleteAnswersToForm
  createUpdateAndDeleteOptions(optionData: [OptionInput], questionId: ID!): CreateUpdateAndDeleteOptions
  createListing(listingData: CreateListingInput!): CreateListing
  updateListing(id: ID!, listingData: BaseListingInput): UpdateListing
  deleteListing(id: ID): DeleteListing
  createOrganization(organizationData: OrganizationInput!): CreateOrganization
  updateOrganization(id: ID!, organizationData: OrganizationInput): UpdateOrganization
  deleteOrganization(id: ID!): DeleteOrganization
  assignMembership(membershipData: MembershipInput!): AssignMembership
  createBooking(bookingData: BookingInput): CreateBooking
  updateBooking(bookingData: UpdateBookingInput): UpdateBooking
  deleteBooking(id: ID): DeleteBooking
  sendEmail(emailInput: EmailInput): SendEmail
  updateBookingSemester(semesterData: UpdateBookingSemesterInput): UpdateBookingSemester
  authUser(code: String): AuthUser
  updateUser(userData: UserInput): UpdateUser
  verifyToken(token: String): Verify
  refreshToken(token: String): Refresh
  deleteTokenCookie: DeleteJSONWebTokenCookie
  getIdToken: GetIDToken
  createArchivedocument(date: DateTime, fileLocation: String, title: String, typeDoc: String, webLink: String): CreateArchiveDocument
  updateArchivedocument(date: DateTime, fileLocation: String, id: ID, title: String, typeDoc: String, webLink: String): UpdateArchiveDocument
  deleteArchivedocument(id: ID): DeleteArchiveDocument
  createEvent(eventData: CreateEventInput!): CreateEvent
  updateEvent(eventData: UpdateEventInput, id: ID!): UpdateEvent
  eventSignUp(data: EventSignUpInput, eventId: ID!): EventSignUp
  eventSignOff(eventId: ID!): EventSignOff
  adminEventSignOff(eventId: ID!, userId: ID!): AdminEventSignOff
  deleteEvent(id: ID): DeleteEvent
  createCategory(categoryData: CategoryInput!): CreateCategory
  updateCategory(categoryData: CategoryInput, id: ID!): UpdateCategory
  deleteCategory(id: ID): DeleteCategory
  sendEventMails(content: String, eventId: ID!, receiverEmails: [String], subject: String!): SendEventEmails
}

input OptionInput {
  answer: String!
  id: ID
}

type OptionType {
  id: ID!
  answer: String!
  question: QuestionType!
}

enum OrderPaymentStatus {
  INITIATED
  RESERVED
  CAPTURED
  CANCELLED
  REFUNDED
  FAILED
  REJECTED
}

type OrderType {
  id: UUID!
  product: ProductType!
  user: UserType!
  quantity: Int!
  totalPrice: Decimal!
  paymentStatus: OrderPaymentStatus!
  timestamp: DateTime!
}

type OrdersByStatusType {
  orders: [OrderType]
  length: Int
}

input OrganizationInput {
  name: String
  description: String
  parentId: ID
}

type OrganizationType {
  id: ID!
  name: String!
  slug: String!
  description: String!
  parent: OrganizationType
  logoUrl: String
  color: String
  users: [UserType!]!
  children: [OrganizationType!]!
  events: [EventType!]!
  absoluteSlug: String
  listings: [ListingType]
  primaryGroup: ResponsibleGroupType
  hrGroup: ResponsibleGroupType
}

type ProductType {
  id: ID!
  name: String!
  price: Decimal!
  description: String!
  maxBuyableQuantity: Int!
}

type Queries {
  hasPermission(permission: String!): Boolean
  allBlogs: [BlogType]
  blog(blogId: ID!): BlogType
  allBlogPosts: [BlogPostType]
  blogPost(blogPostId: ID!): BlogPostType
  product(productId: ID!): ProductType
  products: [ProductType]
  order(orderId: ID!): OrderType
  userOrders: [OrderType]
  ordersByStatus(productId: ID!, status: String!): OrdersByStatusType
  serverTime: DateTime
  form(formId: ID): FormType
  forms: [FormType]
  response(formId: ID!, responseId: ID): ResponseType
  responses(formId: ID!): [ResponseType]
  listings(search: String): [ListingType]
  listing(id: ID): ListingType
  allOrganizations(search: String): [OrganizationType]
  organization(id: ID, slug: String): OrganizationType
  eventFilteredOrganizations: [OrganizationType]
  memberships(organizationId: ID): [MembershipType]
  allBookings: [AllBookingsType]
  adminAllBookings(before: String, after: String): [AdminBookingType]
  cabins: [CabinType]
  activeBookingResponsible: BookingResponsibleType
  bookingSemester: UpdateBookingSemesterType
  allUsers: [UserType]
  user: UserType
  featuredArchive: [ArchiveDocumentType!]!
  archiveByTypes(typeDoc: [String]!, year: Int, names: String): [ArchiveDocumentType!]!
  availableYears: [String!]!
  allEvents(category: String, organization: String, startTime: DateTime, endTime: DateTime): [EventType]
  defaultEvents: [EventType]
  event(id: ID!): EventType
  allCategories: [CategoryType]
  category(id: ID!): CategoryType
  attendeeReport(eventId: ID!, fields: [String], filetype: String): String
  attendeeReports(eventIds: [ID]!, fields: [String], filetype: String): String
  attendeeReportOrg(orgId: ID!, fields: [String], filetype: String): String
  signUps(eventId: ID!): SignUpType
}

type QuestionType {
  id: ID!
  question: String!
  description: String!
  mandatory: Boolean!
  options: [OptionType]
  answers(userId: ID): [AnswerType]
  questionType: QuestionTypeEnum
  answer: AnswerType
}

enum QuestionTypeEnum {
  PARAGRAPH
  SHORT_ANSWER
  MULTIPLE_CHOICE
  CHECKBOXES
  DROPDOWN
  SLIDER
  FILE_UPLOAD
}

type Refresh {
  payload: GenericScalar!
  refreshExpiresIn: Int!
  token: String!
}

enum ResponseStatus {
  NONE
  A_0
  A_1
  A_2
}

type ResponseType {
  uuid: UUID!
  respondent: UserType!
  form: FormType!
  status: ResponseStatus
  answers: [AnswerType!]!
  id: UUID
  questions: [QuestionType]
}

type ResponsibleGroupType {
  uuid: UUID!
  name: String!
  description: String
  organization: OrganizationType!
  groupType: String!
  id: ID!
}

type SendEmail {
  ok: Boolean
}

type SendEventEmails {
  ok: Boolean
}

type SignUpType {
  id: ID!
  timestamp: DateTime!
  isAttending: Boolean!
  extraInformation: String!
  event: EventType!
  user: UserType!
  userEmail: String!
  userPhoneNumber: String!
  userGradeYear: Int!
  hasBoughtTicket: Boolean
  userAllergies: String
}

type SubmitOrUpdateAnswers {
  ok: Boolean
  message: String
}

scalar UUID

type UpdateArchiveDocument {
  ok: Boolean
  event: ArchiveDocumentType
}

type UpdateBlog {
  ok: Boolean
  blog: BlogType
}

input UpdateBlogInput {
  name: String
  description: String
  organizationId: ID
  id: ID!
}

type UpdateBlogPost {
  ok: Boolean
  blogPost: BlogPostType
}

input UpdateBlogPostInput {
  title: String
  text: String
  blogId: ID
  id: ID!
}

type UpdateBooking {
  ok: Boolean
  booking: AllBookingsType
}

input UpdateBookingInput {
  firstName: String
  lastName: String
  phone: String
  receiverEmail: String
  checkIn: Date
  checkOut: Date
  internalParticipants: Int
  externalParticipants: Int
  cabins: [Int]
  id: ID!
  isTentative: Boolean
  isDeclined: Boolean
}

type UpdateBookingSemester {
  ok: Boolean
  bookingSemester: UpdateBookingSemesterType
}

input UpdateBookingSemesterInput {
  fallStartDate: Date
  fallEndDate: Date
  springStartDate: Date
  springEndDate: Date
  fallSemesterActive: Boolean
  springSemesterActive: Boolean
}

type UpdateBookingSemesterType {
  id: ID!
  fallStartDate: Date!
  fallEndDate: Date!
  springStartDate: Date!
  springEndDate: Date!
  fallSemesterActive: Boolean!
  springSemesterActive: Boolean!
}

type UpdateCategory {
  ok: Boolean
  category: CategoryType
}

type UpdateEvent {
  ok: Boolean
  event: EventType
}

input UpdateEventInput {
  title: String
  description: String
  startTime: DateTime
  isAttendable: Boolean
  endTime: DateTime
  location: String
  categoryId: ID
  image: String
  deadline: DateTime
  signupOpenDate: DateTime
  availableSlots: Int
  price: Float
  shortDescription: String
  hasExtraInformation: Boolean
  contactEmail: String
  bindingSignup: Boolean
  allowedGradeYears: [Int]
  organizationId: ID
}

type UpdateForm {
  form: FormType
  ok: Boolean
}

type UpdateListing {
  listing: ListingType
  ok: Boolean
}

type UpdateOrganization {
  organization: OrganizationType
  ok: Boolean
}

type UpdateQuestion {
  ok: Boolean
  question: QuestionType
}

type UpdateUser {
  user: UserType
}

type UserAttendingType {
  isSignedUp: Boolean
  isOnWaitingList: Boolean
  hasBoughtTicket: Boolean
}

input UserInput {
  email: String
  firstName: String
  lastName: String
  graduationYear: Int
  phoneNumber: String
  allergies: String
}

type UserType {
  id: ID!
  lastLogin: DateTime
  username: String!
  firstName: String!
  lastName: String!
  email: String!
  dateJoined: DateTime!
  feideUserid: String!
  feideEmail: String!
  idToken: String!
  phoneNumber: String!
  firstLogin: Boolean!
  graduationYear: Int
  yearUpdatedAt: DateTime
  organizations: [OrganizationType!]!
  memberships: [MembershipType!]!
  responses: [ResponseType!]!
  gradeYear: Int
  events: [EventType]
  allergies: String
  canUpdateYear: Boolean
}

type Verify {
  payload: GenericScalar!
}
